---
title: 2. Using Rcpp in an R package (1)
weight: 2
output:
  blogdown::html_page:
    toc: true
---

<style>
body {
text-align: justify}
</style>

```{r, echo = FALSE, message = FALSE}
system("rm -r mypack")
if("mypack" %in% rownames(installed.packages())) remove.packages("mypack")
```


### Intro to `Rcpp.package.skeleton` and related tools

In this section we will learn how to build a basic `R` package containing `Rcpp` code. The material provided here relies mainly on the [Rcpp-attributes](https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-attributes.pdf) and [Rcpp-package](http://dirk.eddelbuettel.com/code/rcpp/Rcpp-package.pdf) vignettes.

The `Rcpp` package provides an extension of the `utils::package.skeleton` function, which automatically creates a source `R` package which uses several features of `Rcpp`. This is used as follows: 
```{r, message = FALSE}
library(Rcpp)
Rcpp.package.skeleton("mypack")
```
Let's examine the content of the automatically generated `mypack` package:
```{r}
system("ls -1R mypack/")
```
```{r, eval = FALSE}
mypack:
DESCRIPTION
man
NAMESPACE
R
Read-and-delete-me
src

mypack/man:
mypack-package.Rd
rcpp_hello_world.Rd

mypack/R:
RcppExports.R

mypack/src:
RcppExports.cpp
rcpp_hello_world.cpp
```
You should be already familiar with the structure of an `R` package, otherwise see [here](http://r-pkgs.had.co.nz/intro.html), for instance. Here we are particularly interested in `Rcpp`-related components of the package, hence let's look at the `C++` code in `src/rcpp_hello_world.cpp`:
```{r, comment=NA}
printFile <- function(o, n = 1e5) cat(readChar(o, n))
printFile("mypack/src/rcpp_hello_world.cpp")
```
This is an example `C++` function generated by `Rcpp.package.skeleton`. We are not interested in what the function does (despite the name, it doesn't say "hello"!), what matters to us is that the `// [[Rcpp::export]]` attribute indicates that this function should be exported. That is, this is not an internal function, but it should be available to users of the `mypack` package.

To make `rcpp_hello_world` accessible at `R` level, `Rcpp.package.skeleton` calls `compileAttributes` (we will see how to use this function later), which creates a `C++` and `R` wrapper for this function. The `C++` wrapper can in found in:
```{r, comment=NA}
printFile("mypack/src/RcppExports.cpp")
```
Let's examine the content of this file:

  - the first two lines indicate that the file has been generated by `compileAttributes`. If we wanted to edit this file 
    manually, we would have to remove those lines first, otherwise our edits would be overwritten if we were to call 
    `compileAttributes` again;
  - then there is the definition of the `RcppExport SEXP _mypack_rcpp_hello_world()`. This is a standard `Rcpp` wrapper for 
    `rcpp_hello_world`, which makes it accessible from `R` via `.Call` (remember that the latter requires function inputs
    and output of class `SEXP`). Doing `sourceCpp(rcpp_hello_world.cpp)` would generate a similar wrapper, 
    but with a different name.
  - then `static const R_CallMethodDef CallEntries` creates object which lists all the `C++` function that will be 
    accessible from `R` via `.Call`. In our case, the only exported `C++` function is `_mypack_rcpp_hello_world`.
    The `CallEntries` object then appears in the definition of the `R_init_mypack` function. The purpose of this 
    part of the code is registring the native routine (e.g., `C++` functions) provided by the package. In particular,
    the `.Call` interface needs to find the code for the `C++` function being called and registring such routines 
    via `R_registerRoutines` facilitates the search process. For the purpose of this course, understanding how
    registration works is not important, but you might want to read the 
    [relevant section](https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Registering-native-routines) of
    the Writing R Extensions manual if you want more details.
    
As we have just seen `RcppExports.cpp` contains the `Rcpp` wrapper (callable via `.Call`) to the `rcpp_hello_world` `C++` function. The corresponding `R` wrapper is here:
```{r, comment=NA}
printFile("mypack/R/RcppExports.R")
```
This is a straightfoward wrapper, as those generated via `sourceCpp`.

Let's look at the `NAMESPACE` file:
```{r, comment=NA}
printFile("mypack/NAMESPACE")
```
The directive `useDynLib(mypack, .registration=TRUE)` makes so that all the registered routines are loaded in `R`. For example, after installing the package:
```{r}
system("R CMD build mypack")
system("R CMD INSTALL mypack")
```
we can do:
```{r, comment = NA}
mypack:::"_mypack_rcpp_hello_world"
```
which gives information about the routine and we can call the `C++` code directly via:
```{r, comment=NA}
.Call("_mypack_rcpp_hello_world", PACKAGE = "mypack") 
```
See [here](http://www.hep.by/gnu/r-patched/r-exts/R-exts_30.html) for more details on `useDynLib`. The line `exportPattern("^[[:alpha:]]+")` makes so that all the `R` functions whose name starts with a letter of the alphabet will be exported. Then, `importFrom(Rcpp, evalCpp)` is there because packages using `Rcpp` need to import something (anything from `Rcpp`). This requirement is related to a bug in `R`, hence importing something from `Rcpp` might not be needed in the future.

Finally, we look at the Description:
```{r, comment=NA}
printFile("mypack/DESCRIPTION")
```
This is fairly standard, the only things to notice are that `Rcpp` appears both in `LinkingTo` and in `Imports`. Once the above-mentioned bug will be solved, `Rcpp` will need to appear only in `LinkingTo`. The latter is a declarations which allows `R` to retrieve the header file of the target package (`Rcpp` in this case) and to use link them to the compile code in our package. Hence, it cannot be used to link a `C++` library (e.g., the `MKL` library) which is not contained in a `R` package. Linking to external libraries must be done manually using makefiles and it is not covered here.

### Adding a `C++` function to the package 

In the previous section we described the structure of a basic package created by `Rcpp.package.skeleton`. Here we explain how to add further `C++` functions to the package and how to export them. Suppose that we would like to add the following function to our `mypack` package:
```{r, comment=NA}
printFile("dotRcpp.cpp")
```
This function simply calculates the dot product of two numeric vectors. Notice that the function definition is preceded by some comments starting with `//' Dot product in Rcpp.`. These are will be used by `compileAttributes` to build the documentation of this function. To demostrate this, we must move the function to the folder containing the source code:
```{r}
system("cp dotRcpp.cpp mypack/src/dotRcpp.cpp")
```
then we compile the `Rcpp` attributes:
```{r}
compileAttributes("mypack")
```
The `R` wrapper to our `C++` function can be found here:
```{r, comment=NA}
printFile("mypack/R/RcppExports.R")
```
As you can see the dots `dotRcpp` function is preceded by `roxygen` comments, which can be used to produce the corresponding `.Rd` files using `roxygenize("mypack")`. `dotRcpp` is a wrapper around the `C++` function `_mypack_dotRcpp_I`, which is itself a wrapper around the internal `C++` function `dotRcpp_I`, and it is defined here:
```{r, comment=NA}
printFile("mypack/src/RcppExports.cpp")
```
The mechanisms is the same described in the previous section. Notice that the `compileAttribute` will be called automatically when you build your package using Rstudio or `devtools`. 


